# 操作系统

## 概述

### 基本特征

#### 1. 并发

并发指宏观上一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。

并行需要硬件支持：多流水线、多处理器。

操作系统引入进程和线程，使程序能够并发运行。

#### 2. 共享

共享指多个进程同时使用系统资源。

两种共享：互斥共享和同时共享。

互斥共享使用的是临界资源，同一时刻只允许一个进程访问，需要用同步机制实现互斥访问。

同步原语：

- 互斥锁
- 信号量
- 条件变量
- 读写锁

#### 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时分复用和空分复用。

多进程在同一个处理器上并发执行使用了时分复用，轮流占用处理器。

虚拟内存使用了空分复用，将物理内存抽象为地址空间，每个进程都有自己的地址空间。

#### 4. 异步

异步指进程不是一次性执行完毕，走走停停。

### 基本功能

#### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

#### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

#### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护。

#### 4. 设备管理

完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虚拟设备等。

### 系统调用

一个进程在用户态要用到内核态的功能，就进行系统调用，从而陷入内核，由操作系统代完成。

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f74475056302e](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f74475056302e.png)

Linux 的系统调用主要有以下这些（暂不了解）：

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |

### 宏内核和微内核

#### 1. 宏内核

将操作系统作为紧密结合的整体放到内核。

由于各模块共享信息，所以性能高。

#### 2. 微内核

将一部分操作系统功能移出内核，降低内核复杂性。移出部分根据分层原则划分为若干服务，相互独立。

只有微内核运行在内核态，其它模块运行在用户态。

频繁在用户态和内核态切换，有一定的性能损失。

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f325f31345f6d6963726f6b65726e656c4172636869746563747572652e6a7067](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f325f31345f6d6963726f6b65726e656c4172636869746563747572652e6a7067.jpg)

### 中断分类

#### 1. 外中断

由CPU执行指令以外的事件引起（表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求），如I/O完成中断、始终中断、控制台中断等。

#### 2. 异常

由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

#### 3. 陷入

用户程序使用系统调用。

## 进程管理

### 进程与线程

#### 1. 进程

是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。（时分复用）

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61366163326230382d333836312d346538352d626161382d3338323238376266656539662e706e67](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61366163326230382d333836312d346538352d626161382d3338323238376266656539662e706e67.png)

#### 2. 线程

是独立调度的基本单位。

一个进程中可以有多个线程，共享进程资源。（互斥共享、同时共享）

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33636436333065612d303137632d343838642d616431642d3733326234656665646466352e706e67](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33636436333065612d303137632d343838642d616431642d3733326234656665646466352e706e67.png)

浏览器是一个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

#### 3. 区别

以下是将您的描述转化为表格的形式：

|          | 进程                                                         | 线程                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 拥有资源 | 进程是资源分配的基本单位，拥有独立的资源                     | 线程不拥有资源，可以访问隶属进程的资源                       |
| 调度     | 进程切换会引起线程切换                                       | 线程是独立调度的基本单位，线程的切换不会引起进程切换（指单个进程中的线程切换） |
| 系统开销 | 创建或撤销进程的开销大，需要分配或回收资源，如内存空间、I/O 设备等 | 创建或撤销线程的开销小，线程切换时只需保存和设置少量寄存器内容 |
| 通信     | 进程间通信需要借助 IPC                                       | 线程间可以通过直接读写同一进程中的数据进行通信               |

### 进程状态的切换

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67.png)

- 就绪（ready）：等待被调度
- 运行（running）
- 阻塞（waiting）：等待资源

注意：

- 只有就绪和运行可以相互转换，其它都是单向。就绪的进程通过调度算法获得CPU时间，转为运行；运行用完分配的CPU时间，转为就绪。
- 阻塞是运行态缺少资源转换而来，这个资源不包括CPU时间。

### 进程调度算法

因地制宜。

#### 1. 批处理系统

没有太多用户操作，目标是保证吞吐量和周转时间。（从**提交**到终止的时间）

##### 1.1 先来先服务 first-come first-served（FCFS）

非抢占式，按请求顺序调度。

不利于短作业，因为要等待前面的长作业执行完毕。

##### 1.2 短作业优先

非抢占，按**估计**运行时间最短调度。

长作业有可能永远得不到调度。

##### 1.3 最短剩余时间有限

短作业优先的抢占式版本，按**剩余**运行时间最短的顺序进行调度。新作业到达时，会与当前进程剩余时间比较。如果新进程需要时间更少，则挂起当前进程，运行新的进程（抢占）。

#### 2. 交互式系统

##### 2.1 时间片轮转

所有就绪进程按FCFS原则排成队列，CPU分配时间，轮转执行进程。

效率和时间片的大小相关：

- 时间片太小，导致进程切换频繁，消耗时间。
- 时间片太大，实时性得不到保证。

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67.png)

##### 2.2 优先级调度

为每个进程分配优先级，按优先级调度。

为防止低优先级进程等不到调度，可随时间推移增加等待进程的优先级。

##### 2.3 多级反馈队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列（依然是时间片轮转），每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列（降低优先级）。这种方式下，之前的进程只需要交换 7 次。

只有上一个队列没有进程在排队，才能调度当前队列上的进程。![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67.png)

#### 3. 实时系统

要求请求在一个确定时间内得到相应。

分为硬实时（必须满足绝对的截止时间）和软实时（可以容忍一定的超时）。

### 进程同步

#### 1. 临界区（这个词多用于描述多线程）

对临界资源进行访问的代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```
// entry section
// critical section; 只有这一部分是临界区
// exit section
```

#### 2. 同步与互斥

- 同步：多进程因合作产生的直接制约关系，使进程有一定的先后执行顺序。
- 互斥：多进程在同一时刻只能有一个进程进入临界区。

#### 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0（此时还未进入临界区）；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

```
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

 **使用信号量实现生产者-消费者问题**

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty); // 注意，empty和mutex的顺序不能颠倒
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

#### 4. 管程

信号量机制需要客户端代码做很多控制，管程把控制的代码独立出来，客户端只需要调用方法。

一个时刻只能有一个进程使用管程。进程无法执行时不能一直占用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

### 经典同步问题

#### 1. 哲学家进餐问题

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

为了防止死锁：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

#### 2. 读者-写者问题

允许多进程同时对数据进行读操作，不能同时读写，也不能同时写。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

写者只需要使用 data_mutex 对写的数据加锁。

### 进程通信

进程同步和进程通信的区别：

- 同步：控制多进程按一定顺序执行。
- 通信：进程间传输消息。

通信是手段，同步是目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

#### 1. 管道

- 半双工通信。
- 只能在父子进程或兄弟进程中使用。

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35336364396164652d623061362d343339392d623464652d3766316662643036636466622e706e67](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35336364396164652d623061362d343339392d623464652d3766316662643036636466622e706e67.png)

#### 2. FIFO

命名管道，去除了管道只能在父子进程中使用的限制。

常用于C-S中。

![68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32616335306238312d643932612d343430312d623965632d6632313133656363333037362e706e67](figures/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32616335306238312d643932612d343430312d623965632d6632313133656363333037362e706e67.png)

#### 3. 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在（作为一个独立的实体存在，不依赖于创建它的进程），从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题（进程可以立即返回并执行其他操作，而不是等待队列可以执行），不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息（如只接收优先级最高的消息），而不像 FIFO 那样只能默认地接收。

#### 4. 信号量

计数器。

在进程间通信的情境下，信号量可以用来传递信息或者是信号。一个进程可以通过增加信号量值来向其他进程发送一个信号，其他进程可以通过检查信号量值来接收这个信号。

和进程同步中的信号量是同一种机制，但是使用方式和目的有所不同。

#### 5. 共享存储

允许多个进程共享一个给定的存储区。这是最快的一种IPC。

需要用信号量来同步对共享存储的访问。

#### 6. 套接字

可用于不同机器间的进程通信。
